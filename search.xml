<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[火星通行证]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%B8%A6%E7%9D%80%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%8A%E7%81%AB%E6%98%9F%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件事件和委托的关系：是由一个私有的委托变量和_add _remove方法注册组成的事件的非简化写法：声明一个私有的委托变量和 add remov 方法错误的说法“事件一种特殊的委托”事件、索引器、属性本质上都是方法。接口中可以定义什么？接口中只可以定义方法。接口中也可以定义事件、索引器、属性，因为他们本质上都是方法12345678910111213141516171819202122232425262728293031323334353637class Program&#123; static void Main(string[] args) &#123; Person p1 = new Person(); p1.BenMingNian += BMN;//p1.BenMingNian = p1.BenMingNian+ BMN; //p1.BenMingNian += BMN2;//方法的参数返回值要和事件的委托一致 //p1.BenMingNian += BMN3; //p1.BenMingNian -= BMN; //p1.BenMingNian = null; p1.Age = 12; Console.WriteLine(p1.Age); p1.Age = 5; Console.WriteLine(p1.Age); p1.Age = 24; Console.WriteLine(p1.Age); Console.ReadKey(); &#125; static void BMN() &#123; Console.WriteLine("我是本命年!"); &#125; static void BMN2() &#123; Console.WriteLine("我是第二!"); &#125; static void BMN3() &#123; Console.WriteLine("我是第三!"); &#125;&#125; Person类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person&#123; private int age; public int Age &#123; get &#123; return this.age; &#125; set &#123; this.age = value; //if (value % 12 == 0) //&#123; // if (BenMingNian != null) // BenMingNian();//调用添加的组合的方法 //&#125; if (this._BenMingNian != null) this._BenMingNian(); &#125; &#125; // public event Action BenMingNian;//event 委托类型 事件名称 //public Action BenMingNian;//加上 event 就是事件，去掉event就是个普通的委托 private Action _BenMingNian; public event Action BenMingNian &#123; //属性：set; get;set_Age;get_Age //索引：get;set; set_Item,get_Item //事件：add、remove； add_***,remov_*** add &#123; this._BenMingNian += value; &#125; remove &#123; this._BenMingNian -= value; &#125; &#125; //事件和委托的关系：是由一个私有的委托变量和 _add*** _remove*** 方法注册组成的 //事件的非简化写法：声明一个私有的委托变量和 add remov 方法 //错误的说法“事件一种特殊的委托” //事件、索引器、属性本质上都是方法。 //接口中可以定义什么？接口中只可以定义方法。接口中也可以定义事件、索引器、属性，因为他们本质上都是方法&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[委托的组合]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%A7%94%E6%89%98%E7%9A%84%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[委托的组合委托是可以相加的，可以形成一个新的委托对象，调用这个新的委托对象的时候，会按顺序把组合的委托依次执行；MyDel zh = new MyDel(F1) + new MyDel(F1) + new MyDel(F1);1234567891011121314151617181920212223242526272829303132333435363738class Program &#123; static void Main(string[] args) &#123; MyDel d1 = F1;//MyDel d1=new MyDel(F1); MyDel d2 = F2; MyDel d3 = F3; MyDel zh = d1 + d2 + d3;//委托是可以相加的，可以形成一个新的委托对象， //调用这个新的委托对象的时候，会按顺序把组合的委托依次执行； //MyDel zh = new MyDel(F1) + new MyDel(F1) + new MyDel(F1); zh(6); MyDel zh2 = d1 + d3; Console.WriteLine("第二次："); zh2(8); Console.WriteLine("第三次："); zh = zh - d1; zh(3); Console.ReadKey(); &#125; static void F1(int i) &#123; Console.WriteLine("我是F1=" + i); &#125; static void F2(int i) &#123; Console.WriteLine("我是F2=" + i * 2); &#125; static void F3(int i) &#123; Console.WriteLine("我是F3=" + i * i); &#125; delegate void MyDel(int i); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[委托-匿名方法-lambda表达式]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%A7%94%E6%89%98-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用Delegate的时候很多时候没必要使用一个普通的方法，因为这个方法只有这个Delegate会用，并且只用一次，这时候使用匿名方法最合适。匿名方法就是没有名字的方法。 MyDelegate p = delegate(int s) { s = 10; }; 在IL中编译器是给匿名方法生成了名字的1Action&lt;int&gt; a1 = delegate(int i) &#123; Console.WriteLine(i); &#125;; 匿名方法最大的作用，是用来推导出lambda表达式 lambda表达式函数式编程，在Entity framework编程中用的很多=&gt;读作goes to 12345678910111213141516171819202122//lambda表达式格式的匿名方法的写法 Action&lt;int&gt; a2 = (int i) =&gt; &#123; Console.WriteLine(i); &#125;; Action&lt;int&gt; a3 = (i) =&gt; &#123; Console.WriteLine(i); &#125;; //如果只有一个参数，可以不写括号 Action&lt;int&gt; a4 = i =&gt; &#123; Console.WriteLine(i); &#125;; a1(6); //Func&lt;string, int, bool&gt; f1 = delegate(string s, int i) &#123; return true; &#125;; //Func&lt;string, int, bool&gt; f2 = (string s, int i) =&gt; &#123; return true; &#125;; //Func&lt;string, int, bool&gt; f3 = (s, i) =&gt; &#123; return true; &#125;; ////只有一行代码且为返回值，可以省略方法体和return; //Func&lt;string, int, bool&gt; f4 = (s, i) =&gt; true; Func&lt;int, int&gt; f1 = delegate(int i) &#123; return i * 2; &#125;; Func&lt;int, int&gt; f2 = (int i) =&gt; &#123; return i * 2; &#125;; Func&lt;int, int&gt; f3 = i =&gt; i * 2; int j = f3(5); Console.WriteLine(j); 普通匿名类型也是一样用lambda表达式 lambda表达式改造GetMax举个栗子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Program &#123; static void Main(string[] args) &#123; int[] nums = new int[] &#123; 1, 3, 55, 66 &#125;; //int m = GetMax(nums, compereInt); //1 //Func&lt;int, int, bool&gt; f = delegate(int i1, int i2) &#123; return i1 &gt; i2; &#125;; //int m = GetMax(nums,f); //2 //int m = GetMax(nums, delegate (int i1,int i2)&#123; return i1 &gt; i2;&#125;); //3 //int m = GetMax(nums, (i1, i2) =&gt; &#123; return i1 &gt; i2; &#125;); Person[] Persons = new Person[] &#123; new Person("baidu", 8), new Person("sina", 9), new Person("qq", 10) &#125;; Person p = GetMax(Persons, (p1, p2) =&gt; p1.Age &gt; p2.Age); Console.WriteLine(p); Console.ReadKey(); &#125; static bool compereInt(int i1, int i2) &#123; return i1 &gt; i2; &#125; static T GetMax&lt;T&gt;(T[] objs, Func&lt;T, T, bool&gt; compereFunc) &#123; T max = objs[0]; for (int i = 1; i &lt; objs.Length; i++) &#123; if (compereFunc(objs[i], max))//调用func指向的方法，判断谁大，写这段代码的人也不知道func指向哪个方法，只知道func指向的方法有两个object 参数一个bool返回值 max = objs[i]; &#125; return max; &#125; class Person &#123; public Person(string name, int age) &#123; this.Name = name; this.Age = age; &#125; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public override string ToString() &#123; return "name=" + Name + ";age=" + Age; &#125; &#125; &#125; 展开和简化都要有个过程，牢记。 创建MyWhere123456789101112131415161718static class JiHeExt &#123; public static IEnumerable&lt;T&gt; MyWhere&lt;T&gt;(this IEnumerable&lt;T&gt; data, Func&lt;T, bool&gt; func) &#123; //foreach() 什么样的对象可以使用foreach遍历：实现了IEnumerabal接口 //List,数组等都实现了IEnumerable List&lt;T&gt; resultList = new List&lt;T&gt;(); foreach (T item in data) &#123; if (func(item))//遍历到的这条数据是否满足条件func &#123; resultList.Add(item); &#125; &#125; return resultList; &#125; &#125; 调用 12345678910111213141516171819202122static void Main(string[] args) &#123; //int[] nums = new int[] &#123; 3,5,8,10,12,13,15,17&#125;; //IEnumerable&lt;int&gt; r1 = nums.MyWhere(i =&gt; i &gt; 10);//delegate(int)&#123;return i&gt;10;&#125;; //IEnumerable&lt;int&gt; r1 = nums.MyWhere(i =&gt; i%2==0);//delegate(int)&#123;return i&gt;10;&#125;; //foreach (int item in r1) //&#123; // Console.WriteLine(item); //&#125; string [] nums = new string[] &#123;"思宇","老耿","老孙","阿森"&#125;; IEnumerable&lt;string&gt; r1 = nums.MyWhere(s=&gt;s.Contains("老")); foreach (string item in r1) &#123; Console.WriteLine(item); &#125; Console.ReadKey(); &#125;]]></content>
      <tags>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托的定义与应用]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%A7%94%E6%89%98%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[委托的定义delegate声明的语法：delegate int MyDel(int i,string s);MyDel是一个数据类型 可以声明一个变量指向和他类型相容的方法12345public delagete void MyDel(int n); static void M1(int a) &#123; Console.writeLine(a) &#125; MyDel d1=new MyDel(M1);//声明MyDel类型的变量，指向一个指向M1方法的对象//可简化为 MyDel d1=M1;不要声明成MyDel d1=M1();因为加上括号就代表调用方法了，代表“执行指向的方法”，参数就要按照方法的规则传递。委托和null都是引用类型，是可以为null,如果委托变量是null，那么调用的时候就会抛出NullReferenceException 委托的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Program &#123; static void Main(string[] args) &#123; //int[]无法直接转为object[] //int[] num = new int[] &#123; 3, 89, 9, 21 &#125;; object[] nums= new object []&#123;3.14f,55.89f,0.15f,21.3f&#125;; // object m = GetMax(nums, CompareInt); object m = GetMax(nums, new compareFunc(CompareFloat)); person p1 = new person(); p1.Age = 10; p1.name = "baidu"; person p2 = new person(); p2.Age = 20; p2.name = "qq"; person p3 = new person(); p3.Age = 13; p3.name = "sina"; person[] sites = new person[] &#123; p1, p2, p3 &#125;; m= GetMax(sites, ComparePerson); Console.WriteLine(m); Console.ReadKey(); &#125; static bool CompareInt(object obj1, object obj2) &#123; int i1=(int)obj1; int i2=(int)obj2; return i1&gt;i2; &#125; static bool CompareFloat(object obj1, object obj2) &#123; float i1 = (float)obj1;//拆箱和装箱类型得一致 float i2 = (float) obj2; return i1 &gt; i2; &#125; static bool ComparePerson(object obj1, object obj2) &#123; person i1 = (person)obj1; person i2 = (person)obj2; return i1.Age &gt; i2.Age; &#125; static object GetMax(object[] nums, compareFunc func) &#123; object max = nums[0]; for (int i = 1; i &lt; nums.Length; i++) &#123; if (func(nums[i], max))//调用func指向的方法，判断谁大，写这段代码的人也不知道func指向哪个方法，只知道func指向的方法有两个object 参数一个bool返回值 max = nums[i]; &#125; return max; &#125; class person &#123; public int Age &#123; set; get; &#125; public string name &#123; set; get; &#125; public override string ToString() &#123; return "Name=" + name + ",Age=" + Age + ";"; &#125; &#125; //如果obj1比obj2大 返回true 否则 false delegate bool compareFunc (object obj1,object obj2); &#125; 泛型委托12345678910111213141516171819202122232425262728293031class Program &#123; static void Main(string[] args) &#123; //int[]无法直接转为object[] int[] nums = new int[] &#123; 3, 89, 9, 21 &#125;; object m = GetMax(nums, CompareInt); Console.WriteLine(m); Console.ReadKey(); &#125; static bool CompareInt(int obj1, int obj2) &#123; return obj1 &gt; obj2; &#125; static T GetMax&lt;T&gt;(T[] nums, compareFunc&lt;T&gt; func) &#123; T max = nums[0]; for (int i = 1; i &lt; nums.Length; i++) &#123; if (func(nums[i], max))//调用func指向的方法，判断谁大，写这段代码的人也不知道func指向哪个方法，只知道func指向的方法有两个object 参数一个bool返回值 max = nums[i]; &#125; return max; &#125; //如果obj1比obj2大 返回true 否则 false delegate bool compareFunc&lt;T&gt;(T obj1, T obj2); &#125; 内置泛型委托 Action 有参数无返回值的泛型委托 Func 有参数有返回值的泛型委托 最多8个参数 1234567891011121314151617181920212223class Program &#123; static void Main(string[] args) &#123; Action d1 = F1; Action&lt;int, string&gt; d2 = F2; Func&lt;int, int, bool&gt; d3 = CompareInt; &#125; static void F1() &#123; Console.WriteLine("F1"); &#125; static void F2(int i,string s) &#123; Console.WriteLine("F2"); &#125; static bool CompareInt(int i1, int i2) &#123; return i1 &gt; i2; &#125; &#125;]]></content>
      <tags>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[object.ReferenceEquals、字符串缓冲池、ref和out]]></title>
    <url>%2F2019%2F05%2F10%2F222%2F</url>
    <content type="text"><![CDATA[相等object.ReferenceEquals(P1,P2)Equals方法的默认实现是比较两个变量是否是同一个对象。字符串由于override了Equals方法，内部进行内容的比较，所以对于字符串来讲==就是比较内容。 字符串缓冲池字符串不可变字符串是引用类型，每次都创建的话比较浪费内存，所以CLR作了暂存池，在一些情况下，对于字符串对象进行了重用 ref和outref值类型是拷贝引用类型是指定引用ref 就相当于把外部的变量传进来了，在函数内部可以改变外部变量的值的指向（例子：交换两个变量值）使用ref的传参的时候必须写ref swap 2（ref p1，ref p2）在方法内部可以改变变量值也可以不改变变量在传递之前必须赋值 例 int i=1； out的目的是函数返回多个返回值使用out的传参的时候必须写out static void test（out int i）对于out 参数，方法内部就认为他没有被赋值变量传递之前不需要被赋值在方法内部必须给out参数赋值常用于类型转换]]></content>
      <tags>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTS 、CLS、CLR的理解]]></title>
    <url>%2F2019%2F05%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[CTS 、CLS、CLR的理解IL .NET平台的中间语言 可以互通互联，互相调用。CTS 通用数据类型 各个语言编译器把自己语言的类型翻译成CTS中的类型。Int是C#中的类型，Int32是CTS的类型。CLS 不同的语言语法也是不同的，.NET平台规定了通用语言规范CLS可以编译为通用语法，c#可以转为vb等。CLR IL代码石油公共语言运行时（CLR）驱动运行的，CLR提供了垃圾回收（CG）、JIT(即时编译器)]]></content>
      <tags>
        <tag>.NET</tag>
      </tags>
  </entry>
</search>
