<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[委托-匿名方法-lambda表达式]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%A7%94%E6%89%98-%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用Delegate的时候很多时候没必要使用一个普通的方法，因为这个方法只有这个Delegate会用，并且只用一次，这时候使用匿名方法最合适。匿名方法就是没有名字的方法。 MyDelegate p = delegate(int s) { s = 10; }; 在IL中编译器是给匿名方法生成了名字的1Action&lt;int&gt; a1 = delegate(int i) &#123; Console.WriteLine(i); &#125;; 匿名方法最大的作用，是用来推导出lambda表达式 lambda表达式函数式编程，在Entity framework编程中用的很多=&gt;读作goes to 12345678910111213141516171819202122//lambda表达式格式的匿名方法的写法 Action&lt;int&gt; a2 = (int i) =&gt; &#123; Console.WriteLine(i); &#125;; Action&lt;int&gt; a3 = (i) =&gt; &#123; Console.WriteLine(i); &#125;; //如果只有一个参数，可以不写括号 Action&lt;int&gt; a4 = i =&gt; &#123; Console.WriteLine(i); &#125;; a1(6); //Func&lt;string, int, bool&gt; f1 = delegate(string s, int i) &#123; return true; &#125;; //Func&lt;string, int, bool&gt; f2 = (string s, int i) =&gt; &#123; return true; &#125;; //Func&lt;string, int, bool&gt; f3 = (s, i) =&gt; &#123; return true; &#125;; ////只有一行代码且为返回值，可以省略方法体和return; //Func&lt;string, int, bool&gt; f4 = (s, i) =&gt; true; Func&lt;int, int&gt; f1 = delegate(int i) &#123; return i * 2; &#125;; Func&lt;int, int&gt; f2 = (int i) =&gt; &#123; return i * 2; &#125;; Func&lt;int, int&gt; f3 = i =&gt; i * 2; int j = f3(5); Console.WriteLine(j); 普通匿名类型也是一样用lambda表达式 lambda表达式改造GetMax举个栗子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Program &#123; static void Main(string[] args) &#123; int[] nums = new int[] &#123; 1, 3, 55, 66 &#125;; //int m = GetMax(nums, compereInt); //1 //Func&lt;int, int, bool&gt; f = delegate(int i1, int i2) &#123; return i1 &gt; i2; &#125;; //int m = GetMax(nums,f); //2 //int m = GetMax(nums, delegate (int i1,int i2)&#123; return i1 &gt; i2;&#125;); //3 //int m = GetMax(nums, (i1, i2) =&gt; &#123; return i1 &gt; i2; &#125;); Person[] Persons = new Person[] &#123; new Person("baidu", 8), new Person("sina", 9), new Person("qq", 10) &#125;; Person p = GetMax(Persons, (p1, p2) =&gt; p1.Age &gt; p2.Age); Console.WriteLine(p); Console.ReadKey(); &#125; static bool compereInt(int i1, int i2) &#123; return i1 &gt; i2; &#125; static T GetMax&lt;T&gt;(T[] objs, Func&lt;T, T, bool&gt; compereFunc) &#123; T max = objs[0]; for (int i = 1; i &lt; objs.Length; i++) &#123; if (compereFunc(objs[i], max))//调用func指向的方法，判断谁大，写这段代码的人也不知道func指向哪个方法，只知道func指向的方法有两个object 参数一个bool返回值 max = objs[i]; &#125; return max; &#125; class Person &#123; public Person(string name, int age) &#123; this.Name = name; this.Age = age; &#125; public int Age &#123; get; set; &#125; public string Name &#123; get; set; &#125; public override string ToString() &#123; return "name=" + Name + ";age=" + Age; &#125; &#125; &#125; 展开和简化都要有个过程，牢记。 创建MyWhere123456789101112131415161718static class JiHeExt &#123; public static IEnumerable&lt;T&gt; MyWhere&lt;T&gt;(this IEnumerable&lt;T&gt; data, Func&lt;T, bool&gt; func) &#123; //foreach() 什么样的对象可以使用foreach遍历：实现了IEnumerabal接口 //List,数组等都实现了IEnumerable List&lt;T&gt; resultList = new List&lt;T&gt;(); foreach (T item in data) &#123; if (func(item))//遍历到的这条数据是否满足条件func &#123; resultList.Add(item); &#125; &#125; return resultList; &#125; &#125; 调用 12345678910111213141516171819202122static void Main(string[] args) &#123; //int[] nums = new int[] &#123; 3,5,8,10,12,13,15,17&#125;; //IEnumerable&lt;int&gt; r1 = nums.MyWhere(i =&gt; i &gt; 10);//delegate(int)&#123;return i&gt;10;&#125;; //IEnumerable&lt;int&gt; r1 = nums.MyWhere(i =&gt; i%2==0);//delegate(int)&#123;return i&gt;10;&#125;; //foreach (int item in r1) //&#123; // Console.WriteLine(item); //&#125; string [] nums = new string[] &#123;"思宇","老耿","老孙","阿森"&#125;; IEnumerable&lt;string&gt; r1 = nums.MyWhere(s=&gt;s.Contains("老")); foreach (string item in r1) &#123; Console.WriteLine(item); &#125; Console.ReadKey(); &#125;]]></content>
      <tags>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[委托的定义与应用]]></title>
    <url>%2F2019%2F05%2F12%2F%E5%A7%94%E6%89%98%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[委托的定义delegate声明的语法：delegate int MyDel(int i,string s);MyDel是一个数据类型 可以声明一个变量指向和他类型相容的方法12345public delagete void MyDel(int n); static void M1(int a) &#123; Console.writeLine(a) &#125; MyDel d1=new MyDel(M1);//声明MyDel类型的变量，指向一个指向M1方法的对象//可简化为 MyDel d1=M1;不要声明成MyDel d1=M1();因为加上括号就代表调用方法了，代表“执行指向的方法”，参数就要按照方法的规则传递。委托和null都是引用类型，是可以为null,如果委托变量是null，那么调用的时候就会抛出NullReferenceException 委托的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Program &#123; static void Main(string[] args) &#123; //int[]无法直接转为object[] //int[] num = new int[] &#123; 3, 89, 9, 21 &#125;; object[] nums= new object []&#123;3.14f,55.89f,0.15f,21.3f&#125;; // object m = GetMax(nums, CompareInt); object m = GetMax(nums, new compareFunc(CompareFloat)); person p1 = new person(); p1.Age = 10; p1.name = "baidu"; person p2 = new person(); p2.Age = 20; p2.name = "qq"; person p3 = new person(); p3.Age = 13; p3.name = "sina"; person[] sites = new person[] &#123; p1, p2, p3 &#125;; m= GetMax(sites, ComparePerson); Console.WriteLine(m); Console.ReadKey(); &#125; static bool CompareInt(object obj1, object obj2) &#123; int i1=(int)obj1; int i2=(int)obj2; return i1&gt;i2; &#125; static bool CompareFloat(object obj1, object obj2) &#123; float i1 = (float)obj1;//拆箱和装箱类型得一致 float i2 = (float) obj2; return i1 &gt; i2; &#125; static bool ComparePerson(object obj1, object obj2) &#123; person i1 = (person)obj1; person i2 = (person)obj2; return i1.Age &gt; i2.Age; &#125; static object GetMax(object[] nums, compareFunc func) &#123; object max = nums[0]; for (int i = 1; i &lt; nums.Length; i++) &#123; if (func(nums[i], max))//调用func指向的方法，判断谁大，写这段代码的人也不知道func指向哪个方法，只知道func指向的方法有两个object 参数一个bool返回值 max = nums[i]; &#125; return max; &#125; class person &#123; public int Age &#123; set; get; &#125; public string name &#123; set; get; &#125; public override string ToString() &#123; return "Name=" + name + ",Age=" + Age + ";"; &#125; &#125; //如果obj1比obj2大 返回true 否则 false delegate bool compareFunc (object obj1,object obj2); &#125; 泛型委托12345678910111213141516171819202122232425262728293031class Program &#123; static void Main(string[] args) &#123; //int[]无法直接转为object[] int[] nums = new int[] &#123; 3, 89, 9, 21 &#125;; object m = GetMax(nums, CompareInt); Console.WriteLine(m); Console.ReadKey(); &#125; static bool CompareInt(int obj1, int obj2) &#123; return obj1 &gt; obj2; &#125; static T GetMax&lt;T&gt;(T[] nums, compareFunc&lt;T&gt; func) &#123; T max = nums[0]; for (int i = 1; i &lt; nums.Length; i++) &#123; if (func(nums[i], max))//调用func指向的方法，判断谁大，写这段代码的人也不知道func指向哪个方法，只知道func指向的方法有两个object 参数一个bool返回值 max = nums[i]; &#125; return max; &#125; //如果obj1比obj2大 返回true 否则 false delegate bool compareFunc&lt;T&gt;(T obj1, T obj2); &#125; 内置泛型委托 Action 有参数无返回值的泛型委托 Func 有参数有返回值的泛型委托 最多8个参数 1234567891011121314151617181920212223class Program &#123; static void Main(string[] args) &#123; Action d1 = F1; Action&lt;int, string&gt; d2 = F2; Func&lt;int, int, bool&gt; d3 = CompareInt; &#125; static void F1() &#123; Console.WriteLine("F1"); &#125; static void F2(int i,string s) &#123; Console.WriteLine("F2"); &#125; static bool CompareInt(int i1, int i2) &#123; return i1 &gt; i2; &#125; &#125;]]></content>
      <tags>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F11%2F%E5%AE%9E%E7%8E%B0hexo%E5%BC%82%E5%9C%B0%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[title: 实现hexo异地搭建author: menghuaTtags: []categories: [] date: 2019-05-11 19:51:00终于搞定了，公司和家都可以发布GitHub了,最后总结一下经验，主要是有些命令网上博客会有很多版本也有一些不规范导致的多次失败，经过本人不懈的努力和一些朋友的热心帮助，最后终于搞定，在这里记录下，方便查阅。1234567891011121314151617=====================================================准备工作ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;ssh-keygen -t rsa -C&quot;xxxxxx@qq.com&quot;ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;cd ~/.ssh--cmd 四次回车ssh-keygen -t rsa -C &quot;xxxxxx@qq.com&quot;----------hexonpm install -g hexo ---npm install -g cnpm --registry=https://registry.npm.taobao.org---cnpm install hexo-cli -g --安装失败的话可以试试这个hexo init hexo --初始化hexonpm installhexo generatehexo serverhttp://loalhost:4000/ cd /e/Workspaces/hexo/ 搭建hexo参考版]]></content>
  </entry>
  <entry>
    <title><![CDATA[object.ReferenceEquals、字符串缓冲池、ref和out]]></title>
    <url>%2F2019%2F05%2F10%2F222%2F</url>
    <content type="text"><![CDATA[相等object.ReferenceEquals(P1,P2)Equals方法的默认实现是比较两个变量是否是同一个对象。字符串由于override了Equals方法，内部进行内容的比较，所以对于字符串来讲==就是比较内容。 字符串缓冲池字符串不可变字符串是引用类型，每次都创建的话比较浪费内存，所以CLR作了暂存池，在一些情况下，对于字符串对象进行了重用 ref和outref值类型是拷贝引用类型是指定引用ref 就相当于把外部的变量传进来了，在函数内部可以改变外部变量的值的指向（例子：交换两个变量值）使用ref的传参的时候必须写ref swap 2（ref p1，ref p2）在方法内部可以改变变量值也可以不改变变量在传递之前必须赋值 例 int i=1； out的目的是函数返回多个返回值使用out的传参的时候必须写out static void test（out int i）对于out 参数，方法内部就认为他没有被赋值变量传递之前不需要被赋值在方法内部必须给out参数赋值常用于类型转换]]></content>
      <tags>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTS 、CLS、CLR的理解]]></title>
    <url>%2F2019%2F05%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[CTS 、CLS、CLR的理解IL .NET平台的中间语言 可以互通互联，互相调用。CTS 通用数据类型 各个语言编译器把自己语言的类型翻译成CTS中的类型。Int是C#中的类型，Int32是CTS的类型。CLS 不同的语言语法也是不同的，.NET平台规定了通用语言规范CLS可以编译为通用语法，c#可以转为vb等。CLR IL代码石油公共语言运行时（CLR）驱动运行的，CLR提供了垃圾回收（CG）、JIT(即时编译器)]]></content>
      <tags>
        <tag>.NET</tag>
      </tags>
  </entry>
</search>
